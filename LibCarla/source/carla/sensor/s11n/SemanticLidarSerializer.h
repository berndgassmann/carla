// Copyright (c) 2020 Computer Vision Center (CVC) at the Universitat Autonoma
// de Barcelona (UAB).
//
// This work is licensed under the terms of the MIT license.
// For a copy, see <https://opensource.org/licenses/MIT>.

#pragma once

#include "carla/Debug.h"
#include "carla/Memory.h"
#include "carla/sensor/RawData.h"
#include "carla/sensor/data/SemanticLidarData.h"

namespace carla {

namespace ros2 {
  template <class HEADER_TYPE, class DATA_TYPE>
  class UePublisherBasePointCloud;
} // namespace ros2

namespace sensor {

class SensorData;

namespace s11n {

  // ===========================================================================
  // -- SemanticLidarHeaderView --------------------------------------------------------
  // ===========================================================================

  /// A view over the header of a Lidar measurement.
  class SemanticLidarHeaderView {
    using Index = data::SemanticLidarData::Index;

    public:

    float GetHorizontalAngle() const {
      return reinterpret_cast<const float &>(_begin[Index::HorizontalAngle]);
    }

    uint32_t GetChannelCount() const {
      return _begin[Index::ChannelCount];
    }

    uint32_t GetPointCount(size_t channel) const {
      DEBUG_ASSERT(channel < GetChannelCount());
      return _begin[Index::SIZE + channel];
    }

    size_t GetHeaderOffset() const {
      return sizeof(uint32_t) * (GetChannelCount() + Index::SIZE);
    }

    size_t GetDataSize() const {
      size_t data_size=0u;
      for (size_t i=0; i<GetChannelCount(); ++i) {
        data_size+=GetPointCount(i)*sizeof(carla::sensor::data::SemanticLidarDetection);
      }
      return data_size;
    }

  protected:
    friend class SemanticLidarSerializer;
    friend class carla::ros2::UePublisherBasePointCloud<SemanticLidarHeaderView, carla::sensor::data::SemanticLidarDetection>;

    explicit SemanticLidarHeaderView(const uint32_t *begin) : _begin(begin) {
      DEBUG_ASSERT(_begin != nullptr);
    }

    const uint32_t *_begin;
  };

  // ===========================================================================
  // -- LidarSerializer --------------------------------------------------------
  // ===========================================================================

  /// Serializes the data generated by Lidar sensors.
  class SemanticLidarSerializer {
  public:

    static SemanticLidarHeaderView DeserializeHeader(const RawData &data) {
      return SemanticLidarHeaderView{reinterpret_cast<const uint32_t *>(data.begin())};
    }

    static size_t GetHeaderOffset(const RawData &data) {
      auto View = DeserializeHeader(data);
      return View.GetHeaderOffset();
    }

    template <typename Sensor>
    static Buffer Serialize(
        const Sensor &sensor,
        const data::SemanticLidarData &measurement,
        Buffer &&output);

    static SharedPtr<SensorData> Deserialize(RawData DESERIALIZE_DECL_DATA(data));

  };

  // ===========================================================================
  // -- LidarRawSerializer implementation -----------------------------------------
  // ===========================================================================

  template <typename Sensor>
  inline Buffer SemanticLidarSerializer::Serialize(
      const Sensor &,
      const data::SemanticLidarData &measurement,
      Buffer &&output) {
    std::array<boost::asio::const_buffer, 2u> seq = {
        boost::asio::buffer(measurement._header),
        boost::asio::buffer(measurement._ser_points)};
    output.copy_from(seq);
    return std::move(output);
  }

} // namespace s11n
} // namespace sensor
} // namespace carla
